<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesium æœ€å°åŒ–ç¤ºä¾‹ - ä¸‹é›ªæ•ˆæœ</title>
    <link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Widgets/widgets.css">
    <style>
        html, body, #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <canvas id="threeCanvas"></canvas>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>
    
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Cesium.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { createNoise3D } from 'simplex-noise';

        // --- Cesium åˆå§‹åŒ– --- 
        const viewer = new Cesium.Viewer('cesiumContainer', {
            baseLayerPicker: false, // ç¦ç”¨é»˜è®¤å›¾å±‚é€‰æ‹©å™¨ä»¥é¿å… Bing ä¾èµ–
            geocoder: false,
            homeButton: true,
            infoBox: false,
            navigationHelpButton: true,
            sceneModePicker: false,
            timeline: false,
            animation: false,
            fullscreenButton: true,
            shouldAnimate: true
        });

        // ç»‘å®šåˆ°å…¨å±€ä¾¿äºè°ƒè¯•ï¼Œå¹¶æ˜¾å¼è®¾ç½®å…æˆæƒåº•å›¾
        window.viewer = viewer;
        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({
            url: 'https://a.tile.openstreetmap.org/'
        }));

        // ç®€å•è§†è§’ï¼šçº½çº¦ä¸Šç©º
        const position = Cesium.Cartesian3.fromDegrees(-74.0060, 40.7128, 5000);
        viewer.camera.setView({
            destination: position,
            orientation: {
                heading: Cesium.Math.toRadians(0),
                pitch: Cesium.Math.toRadians(-45),
                roll: 0
            }
        });

        // --- Global Variables --- 
        let threeCamera, scene, renderer;
        let particles, geometry, material;
        let noise3D;
        let noiseSeed = Math.random() * 10000;
        
        // State & Parameters
        const params = {
            // Particles
            count: 15000,
            size: 5,
            opacity: 0.8,
            color: 0xffffff,
            
            // Wind (Perlin Noise)
            windSpeed: 1.0,
            windForce: 0.5,
            turbulence: 0.002,
            timeScale: 0.3,
            baseX: 0.2,
            baseY: -1.5,
            
            // Camera HPR (Heading, Pitch, Roll)
            enableMouseControl: false,
            heading: 0,      // Yaw/heading in degrees
            pitch: 0,        // Pitch in degrees
            roll: 0,         // Roll in degrees
            camX: 0,
            camY: 100,
            camZ: 200,
            
            // Camera & Lens
            fov: 75,
            
            // Noise
            noiseOctaves: 3,
            noiseSeed: noiseSeed,
            regenerateNoise: () => regenerateNoise(),
            previewNoise: false
        };

        let particleData = [];
        const areaSize = 2000;
        let clock = new THREE.Clock();

        // --- Three.js åˆå§‹åŒ– --- 
        initThreeJS();
        animate();

        function initThreeJS() {
            noise3D = createNoise3D(() => params.noiseSeed);

            // 1. Scene
            scene = new THREE.Scene();
            scene.background = null;
            
            // 2. Camera
            threeCamera = new THREE.PerspectiveCamera(
                params.fov, 
                window.innerWidth / window.innerHeight, 
                1, 
                3000
            );
            
            // 3. Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('threeCanvas'),
                antialias: false,
                powerPreference: "high-performance",
                alpha: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            
            // 4. Particles
            initParticles();

            // 5. GUI
            initGUI();

            // 6. Events
            window.addEventListener('resize', onWindowResize);
        }

        function regenerateNoise() {
            params.noiseSeed = Math.random() * 10000;
            noise3D = createNoise3D(() => params.noiseSeed);
            alert('å™ªå£°å·²é‡æ–°ç”Ÿæˆï¼Noise regenerated!');
        }

        function initParticles() {
            if (particles) {
                scene.remove(particles);
                geometry.dispose();
            }

            geometry = new THREE.BufferGeometry();
            const vertices = [];
            particleData = [];

            const texture = getSprite();

            for (let i = 0; i < params.count; i++) {
                const x = Math.random() * areaSize - areaSize / 2;
                const y = Math.random() * areaSize - areaSize / 2;
                const z = Math.random() * areaSize - areaSize / 2;
                vertices.push(x, y, z);

                particleData.push({
                    velocity: new THREE.Vector3(0, 0, 0),
                    randomness: Math.random()
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            material = new THREE.PointsMaterial({
                color: params.color,
                size: params.size,
                map: texture,
                transparent: true,
                opacity: params.opacity,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(230,240,255,0.8)');
            gradient.addColorStop(0.4, 'rgba(180,200,230,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function initGUI() {
            const gui = new GUI({ title: 'æ§åˆ¶é¢æ¿ Settings', width: 320 });

            // Camera Control
            const camFolder = gui.addFolder('ğŸ“· ç›¸æœºæ§åˆ¶ (Camera HPR)');
            camFolder.add(params, 'enableMouseControl').name('å¯ç”¨é¼ æ ‡æ§åˆ¶').onChange(updateCameraTransform);
            camFolder.add(params, 'heading', -180, 180).name('èˆªå‘è§’ Heading (Y)').onChange(updateCameraTransform);
            camFolder.add(params, 'pitch', -89, 89).name('ä¿¯ä»°è§’ Pitch (X)').onChange(updateCameraTransform);
            camFolder.add(params, 'roll', -180, 180).name('ç¿»æ»šè§’ Roll (Z)').onChange(updateCameraTransform);
            camFolder.add(params, 'camX', -500, 500).name('ä½ç½® X').onChange(updateCameraTransform);
            camFolder.add(params, 'camY', -500, 500).name('ä½ç½® Y').onChange(updateCameraTransform);
            camFolder.add(params, 'camZ', -500, 500).name('ä½ç½® Z').onChange(updateCameraTransform);
            camFolder.add(params, 'fov', 30, 120).name('è§†é‡ FOV').onChange(() => {
                threeCamera.fov = params.fov;
                threeCamera.updateProjectionMatrix();
            });

            // Environment & Wind
            const envFolder = gui.addFolder('ğŸŒ¬ï¸ ç¯å¢ƒä¸é£åœº (Environment)');
            envFolder.add(params, 'windSpeed', 0, 3).name('æ•´ä½“é£é€Ÿ');
            envFolder.add(params, 'baseY', -5, -0.1).name('ä¸‹è½é€Ÿåº¦');
            envFolder.add(params, 'baseX', -2, 2).name('ä¾§å‘é£åŠ›');
            envFolder.add(params, 'windForce', 0, 2).name('å™ªå£°å¼ºåº¦');
            envFolder.add(params, 'turbulence', 0.0001, 0.01).name('å™ªå£°å¯†åº¦');
            envFolder.add(params, 'timeScale', 0.0, 2.0).name('é£åœºå˜åŒ–ç‡');

            // Noise Control
            const noiseFolder = gui.addFolder('ğŸ² å™ªå£°æ§åˆ¶ (Noise)');
            noiseFolder.add(params, 'noiseOctaves', 1, 6, 1).name('å™ªå£°ç»†èŠ‚å±‚æ¬¡');
            noiseFolder.add(params, 'regenerateNoise').name('ğŸ”„ é‡æ–°ç”Ÿæˆå™ªå£°');
            noiseFolder.add(params, 'previewNoise').name('é¢„è§ˆå™ªå£°åœº').onChange(toggleNoisePreview);

            // Particles
            const partFolder = gui.addFolder('â„ï¸ é›ªèŠ±çŠ¶æ€ (Snow)');
            partFolder.add(params, 'count', 1000, 50000, 100).name('æ•°é‡').onFinishChange(initParticles);
            partFolder.add(params, 'size', 1, 20).name('å¤§å°').onChange(v => material.size = v);
            partFolder.add(params, 'opacity', 0, 1).name('é€æ˜åº¦').onChange(v => material.opacity = v);
            partFolder.addColor(params, 'color').name('é¢œè‰²').onChange(v => material.color.setHex(v));

            camFolder.open();
        }

        function toggleNoisePreview(show) {
            // ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸æ˜¾ç¤ºå™ªå£°é¢„è§ˆ
        }

        function updateCameraTransform() {
            threeCamera.position.set(params.camX, params.camY, params.camZ);
            
            // Convert HPR to rotation
            const heading = THREE.MathUtils.degToRad(params.heading);
            const pitch = THREE.MathUtils.degToRad(params.pitch);
            const roll = THREE.MathUtils.degToRad(params.roll);
            
            threeCamera.rotation.order = 'YXZ';
            threeCamera.rotation.y = heading;
            threeCamera.rotation.x = pitch;
            threeCamera.rotation.z = roll;
        }

        function onWindowResize() {
            threeCamera.aspect = window.innerWidth / window.innerHeight;
            threeCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // åŒæ­¥ Cesium ç›¸æœºåˆ° Three.js ç›¸æœº
            syncCesiumToThreeCamera();

            // Snow Particles Physics
            const positions = particles.geometry.attributes.position.array;
            const timeOffset = elapsedTime * params.timeScale;
            const turb = params.turbulence;
            const force = params.windForce;
            const globalSpeed = params.windSpeed;
            const baseX = params.baseX;
            const baseY = params.baseY;

            for (let i = 0; i < params.count; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let px = positions[ix];
                let py = positions[iy];
                let pz = positions[iz];

                // Multi-octave 3D noise
                let noiseX = 0, noiseY = 0, noiseZ = 0;
                let amplitude = 1;
                let frequency = 1;
                
                for (let oct = 0; oct < params.noiseOctaves; oct++) {
                    noiseX += noise3D(px * turb * frequency, py * turb * frequency, timeOffset + oct * 100) * amplitude;
                    noiseY += noise3D(px * turb * frequency + 100, py * turb * frequency, timeOffset + oct * 100) * amplitude;
                    noiseZ += noise3D(px * turb * frequency + 200, py * turb * frequency, timeOffset + oct * 100) * amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }

                const vx = (baseX + noiseX * force) * globalSpeed;
                const vy = (baseY + noiseY * force * 0.5) * globalSpeed;
                const vz = (noiseZ * force) * globalSpeed;

                positions[ix] += vx;
                positions[iy] += vy;
                positions[iz] += vz;

                // Boundary check
                const boundary = areaSize / 2;
                
                if (positions[iy] < -boundary) {
                    positions[iy] = boundary;
                    positions[ix] = (Math.random() - 0.5) * areaSize;
                    positions[iz] = (Math.random() - 0.5) * areaSize;
                }
                if (positions[ix] > boundary) positions[ix] = -boundary;
                if (positions[ix] < -boundary) positions[ix] = boundary;
                if (positions[iz] > boundary) positions[iz] = -boundary;
                if (positions[iz] < -boundary) positions[iz] = boundary;
            }

            particles.geometry.attributes.position.needsUpdate = true;

            // Direct render without post-processing
            renderer.render(scene, threeCamera);
        }

        // åŒæ­¥ Cesium ç›¸æœºåˆ° Three.js ç›¸æœº
        function syncCesiumToThreeCamera() {
            const cesiumCamera = viewer.camera;

            // Cesium ä½¿ç”¨ East-North-Up (X=ä¸œ, Y=åŒ—, Z=ä¸Š)
            // Three ä½¿ç”¨ X=å³, Y=ä¸Š, Z=æœå±å¹•å¤–ï¼ˆç›¸æœºçœ‹å‘ -Zï¼‰
            // å› æ­¤éœ€è¦åšè½´é‡æ˜ å°„ï¼šThree = (x, z, -y) from Cesium
            const toThree = (v) => new THREE.Vector3(v.x, v.z, -v.y);

            const dir = toThree(cesiumCamera.direction).normalize(); // å‰æ–¹
            const up = toThree(cesiumCamera.up).normalize();         // ä¸Šæ–¹
            const right = toThree(cesiumCamera.right).normalize();   // å³æ–¹

            // è®© Three ç›¸æœºé¢å‘ Cesium çš„å‰æ–¹ï¼šThree ç›¸æœºçš„ -Z å¯¹é½ Cesium çš„ direction
            const zAxis = dir.clone().multiplyScalar(-1);

            const basis = new THREE.Matrix4();
            basis.makeBasis(right, up, zAxis);
            threeCamera.setRotationFromMatrix(basis);

            // ç²’å­å±‚å›ºå®šåœ¨åŸç‚¹ï¼ŒåªåŒæ­¥æœå‘ï¼›ä½ç½®ä¿æŒ 0 é¿å…å¼•å…¥ä½ç§»å·®
            threeCamera.position.set(0, 0, 0);
        }
    </script>
</body>
</html>
