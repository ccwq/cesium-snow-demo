<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesium + Three.js ‰∏ãÈõ™ÊïàÊûú - HPRÂêåÊ≠•‰øÆÂ§çÁâà</title>
    <link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Widgets/widgets.css">
    <style>
        html, body, #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 2;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <canvas id="threeCanvas"></canvas>
    <div id="info"></div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>
    
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Cesium.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { createNoise3D } from 'simplex-noise';

        // --- Cesium ÂàùÂßãÂåñ --- 
        const viewer = new Cesium.Viewer('cesiumContainer', {
            baseLayerPicker: false,
            geocoder: false,
            homeButton: true,
            infoBox: false,
            navigationHelpButton: true,
            sceneModePicker: false,
            timeline: false,
            animation: false,
            fullscreenButton: true,
            shouldAnimate: true
        });

        window.viewer = viewer;
        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({
            url: 'https://a.tile.openstreetmap.org/'
        }));

        const position = Cesium.Cartesian3.fromDegrees(-74.0060, 40.7128, 5000);
        viewer.camera.setView({
            destination: position,
            orientation: {
                heading: Cesium.Math.toRadians(0),
                pitch: Cesium.Math.toRadians(-45),
                roll: 0
            }
        });

        // --- Global Variables --- 
        let threeCamera, scene, renderer;
        let particles, geometry, material;
        let noise3D;
        let noiseSeed = Math.random() * 10000;
        const guiState = { controllers: {}, syncing: false };
        
        // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁªü‰∏ÄÁöÑÂùêÊ†áËΩ¨Êç¢Áü©Èòµ
        const cesiumToThreeMatrix = new THREE.Matrix4();
        // Cesium: X=‰∏ú, Y=Âåó, Z=‰∏ä -> Three: X=‰∏ú, Y=‰∏ä, Z=Âçó
        cesiumToThreeMatrix.set(
            1,  0,  0, 0,
            0,  0,  1, 0,
            0, -1,  0, 0,
            0,  0,  0, 1
        );
        
        const lastStableBasis = {
            east: new THREE.Vector3(1, 0, 0),
            north: new THREE.Vector3(0, 0, -1),
            up: new THREE.Vector3(0, 1, 0),
            down: new THREE.Vector3(0, -1, 0),
            valid: false
        };
        
        // State & Parameters
        const params = {
            count: 15000,
            size: 5,
            opacity: 0.8,
            color: 0xffffff,
            
            windSpeed: 1.0,
            windForce: 0.5,
            turbulence: 0.002,
            timeScale: 0.3,
            baseX: 0.2,
            baseY: -1.5,
            
            enableMouseControl: false,
            heading: 0,
            pitch: -45,
            roll: 0,
            camX: -74.0060,
            camY: 40.7128,
            camZ: 5000,
            
            fov: 75,
            syncFov: false,  // Êñ∞Â¢ûÔºöÊòØÂê¶ÂêåÊ≠•CesiumÁöÑFOV
            
            noiseOctaves: 3,
            noiseSeed: noiseSeed,
            regenerateNoise: () => regenerateNoise(),
            
            // Êñ∞Â¢ûÔºöË∞ÉËØï‰ø°ÊÅØ
            showDebugInfo: true
        };

        let particleData = [];
        const areaSize = 2000;
        let clock = new THREE.Clock();

        // --- Three.js ÂàùÂßãÂåñ --- 
        initThreeJS();
        animate();

        function initThreeJS() {
            noise3D = createNoise3D(() => params.noiseSeed);

            scene = new THREE.Scene();
            scene.background = null;
            
            threeCamera = new THREE.PerspectiveCamera(
                params.fov, 
                window.innerWidth / window.innerHeight, 
                1, 
                3000
            );
            
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('threeCanvas'),
                antialias: false,
                powerPreference: "high-performance",
                alpha: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            
            initParticles();
            initGUI();
            syncParamsFromCesiumCamera();

            window.addEventListener('resize', onWindowResize);
        }

        function regenerateNoise() {
            params.noiseSeed = Math.random() * 10000;
            noise3D = createNoise3D(() => params.noiseSeed);
        }

        function initParticles() {
            if (particles) {
                scene.remove(particles);
                geometry.dispose();
            }

            geometry = new THREE.BufferGeometry();
            const vertices = [];
            particleData = [];

            const texture = getSprite();

            for (let i = 0; i < params.count; i++) {
                const x = Math.random() * areaSize - areaSize / 2;
                const y = Math.random() * areaSize - areaSize / 2;
                const z = Math.random() * areaSize - areaSize / 2;
                vertices.push(x, y, z);

                particleData.push({
                    velocity: new THREE.Vector3(0, 0, 0),
                    randomness: Math.random()
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            material = new THREE.PointsMaterial({
                color: params.color,
                size: params.size,
                map: texture,
                transparent: true,
                opacity: params.opacity,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(230,240,255,0.8)');
            gradient.addColorStop(0.4, 'rgba(180,200,230,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function initGUI() {
            const gui = new GUI({ title: 'ÊéßÂà∂Èù¢Êùø', width: 320 });

            const camFolder = gui.addFolder('üì∑ Áõ∏Êú∫ÊéßÂà∂');
            guiState.controllers.enableMouseControl = camFolder.add(params, 'enableMouseControl').name('ÂêØÁî®Èº†Ê†áÊéßÂà∂');
            guiState.controllers.heading = camFolder.add(params, 'heading', -180, 180).name('Ëà™ÂêëËßí Heading (¬∞)').onChange(onGuiPoseChanged);
            guiState.controllers.pitch = camFolder.add(params, 'pitch', -89, 89).name('‰øØ‰ª∞Ëßí Pitch (¬∞)').onChange(onGuiPoseChanged);
            guiState.controllers.roll = camFolder.add(params, 'roll', -180, 180).name('ÁøªÊªöËßí Roll (¬∞)').onChange(onGuiPoseChanged);
            guiState.controllers.camX = camFolder.add(params, 'camX', -180, 180).name('ÁªèÂ∫¶ (¬∞)').onFinishChange(onGuiPoseChanged);
            guiState.controllers.camY = camFolder.add(params, 'camY', -90, 90).name('Á∫¨Â∫¶ (¬∞)').onFinishChange(onGuiPoseChanged);
            guiState.controllers.camZ = camFolder.add(params, 'camZ', 0, 500000).name('È´òÂ∫¶ (m)').onFinishChange(onGuiPoseChanged);
            guiState.controllers.syncFov = camFolder.add(params, 'syncFov').name('üîó ÂêåÊ≠•Cesium FOV');
            guiState.controllers.fov = camFolder.add(params, 'fov', 30, 120).name('ËßÜÈáé FOV (¬∞)').onChange(() => {
                threeCamera.fov = params.fov;
                threeCamera.updateProjectionMatrix();
            });

            const envFolder = gui.addFolder('üå¨Ô∏è ÁéØÂ¢É‰∏éÈ£éÂú∫');
            envFolder.add(params, 'windSpeed', 0, 3).name('Êï¥‰ΩìÈ£éÈÄü');
            envFolder.add(params, 'baseY', -5, -0.1).name('‰∏ãËêΩÈÄüÂ∫¶');
            envFolder.add(params, 'baseX', -2, 2).name('‰æßÂêëÈ£éÂäõ');
            envFolder.add(params, 'windForce', 0, 2).name('Âô™Â£∞Âº∫Â∫¶');
            envFolder.add(params, 'turbulence', 0.0001, 0.01).name('Âô™Â£∞ÂØÜÂ∫¶');
            envFolder.add(params, 'timeScale', 0.0, 2.0).name('È£éÂú∫ÂèòÂåñÁéá');

            const noiseFolder = gui.addFolder('üé≤ Âô™Â£∞ÊéßÂà∂');
            noiseFolder.add(params, 'noiseOctaves', 1, 6, 1).name('Âô™Â£∞ÁªÜËäÇÂ±ÇÊ¨°');
            noiseFolder.add(params, 'regenerateNoise').name('üîÑ ÈáçÊñ∞ÁîüÊàêÂô™Â£∞');

            const partFolder = gui.addFolder('‚ùÑÔ∏è Èõ™Ëä±ËÆæÁΩÆ');
            partFolder.add(params, 'count', 1000, 50000, 100).name('Êï∞Èáè').onFinishChange(initParticles);
            partFolder.add(params, 'size', 1, 20).name('Â§ßÂ∞è').onChange(v => material.size = v);
            partFolder.add(params, 'opacity', 0, 1).name('ÈÄèÊòéÂ∫¶').onChange(v => material.opacity = v);
            partFolder.addColor(params, 'color').name('È¢úËâ≤').onChange(v => material.color.setHex(v));

            const debugFolder = gui.addFolder('üîß Ë∞ÉËØï');
            debugFolder.add(params, 'showDebugInfo').name('ÊòæÁ§∫Ë∞ÉËØï‰ø°ÊÅØ');

            camFolder.open();
        }

        function syncParamsFromCesiumCamera() {
            if (!guiState.controllers.heading) return;
            const cesiumCamera = viewer.camera;
            const headingDeg = Cesium.Math.toDegrees(cesiumCamera.heading);
            const pitchDeg = Cesium.Math.toDegrees(cesiumCamera.pitch);
            const rollDeg = Cesium.Math.toDegrees(cesiumCamera.roll);
            const cartesianPos = cesiumCamera.positionWC || cesiumCamera.position;
            const carto = Cesium.Cartographic.fromCartesian(cartesianPos);
            const lonDeg = Cesium.Math.toDegrees(carto.longitude);
            const latDeg = Cesium.Math.toDegrees(carto.latitude);
            const height = carto.height;

            guiState.syncing = true;
            params.heading = headingDeg;
            params.pitch = pitchDeg;
            params.roll = rollDeg;
            params.camX = lonDeg;
            params.camY = latDeg;
            params.camZ = height;
            guiState.controllers.heading.setValue(headingDeg);
            guiState.controllers.pitch.setValue(pitchDeg);
            guiState.controllers.roll.setValue(rollDeg);
            guiState.controllers.camX.setValue(lonDeg);
            guiState.controllers.camY.setValue(latDeg);
            guiState.controllers.camZ.setValue(height);
            guiState.syncing = false;
        }

        function applyGuiPoseToCesium() {
            const heading = Cesium.Math.toRadians(params.heading);
            const pitch = Cesium.Math.toRadians(params.pitch);
            const roll = Cesium.Math.toRadians(params.roll);
            const destination = Cesium.Cartesian3.fromDegrees(params.camX, params.camY, params.camZ);
            viewer.camera.setView({
                destination,
                orientation: { heading, pitch, roll }
            });
        }

        // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊ≠£Á°ÆÁöÑ Cesium Âà∞ Three.js ÂêëÈáèËΩ¨Êç¢
        function cesiumToThreeVector(cesiumVec) {
            // Cesium ECEF: X=Ëµ§ÈÅì0¬∞, Y=Ëµ§ÈÅì90¬∞E, Z=ÂåóÊûÅ
            // Three.js: X=Âè≥, Y=‰∏ä, Z=ÂêëÂ§ñ(ÊúùÂêëËßÇÂØüËÄÖ)
            return new THREE.Vector3(
                cesiumVec.x,
                cesiumVec.z,
                -cesiumVec.y
            );
        }

        // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊûÑÈÄ†Ê≠£Á°ÆÁöÑ ENU ÂùêÊ†áÂü∫
        function getLocalEnuBasis() {
            const pos = viewer.camera.positionWC || viewer.camera.position;
            if (!pos) return lastStableBasis;

            const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(
                pos,
                Cesium.Ellipsoid.WGS84
            );

            const cesiumEast = new Cesium.Cartesian3();
            const cesiumNorth = new Cesium.Cartesian3();
            const cesiumUp = new Cesium.Cartesian3();

            Cesium.Matrix4.getColumn(enuMatrix, 0, cesiumEast);
            Cesium.Matrix4.getColumn(enuMatrix, 1, cesiumNorth);
            Cesium.Matrix4.getColumn(enuMatrix, 2, cesiumUp);

            const east = cesiumToThreeVector(cesiumEast).normalize();
            const north = cesiumToThreeVector(cesiumNorth).normalize();
            const up = cesiumToThreeVector(cesiumUp).normalize();

            if (!isValidVector3(east) || !isValidVector3(north) || !isValidVector3(up)) {
                return lastStableBasis;
            }

            const blend = lastStableBasis.valid ? 0.85 : 0.0;
            lastStableBasis.east.lerpVectors(east, lastStableBasis.east, blend).normalize();
            lastStableBasis.north.lerpVectors(north, lastStableBasis.north, blend).normalize();
            lastStableBasis.up.lerpVectors(up, lastStableBasis.up, blend).normalize();
            lastStableBasis.down.copy(lastStableBasis.up).multiplyScalar(-1);
            lastStableBasis.valid = true;
            return lastStableBasis;
        }

        function isValidVector3(v) {
            return Number.isFinite(v.x) && Number.isFinite(v.y) && Number.isFinite(v.z) && v.lengthSq() > 1e-10;
        }

        function onGuiPoseChanged() {
            if (guiState.syncing) return;
            applyGuiPoseToCesium();
        }

        function onWindowResize() {
            threeCamera.aspect = window.innerWidth / window.innerHeight;
            threeCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // ÂÖ≥ÈîÆÔºöÂêåÊ≠•Áõ∏Êú∫
            syncCesiumToThreeCamera();
            syncParamsFromCesiumCamera();

            // Êõ¥Êñ∞Á≤íÂ≠ê
            updateParticles(elapsedTime);

            // Ê∏≤Êüì
            renderer.render(scene, threeCamera);
            
            // Ë∞ÉËØï‰ø°ÊÅØ
            if (params.showDebugInfo) {
                updateDebugInfo();
            } else {
                document.getElementById('info').style.display = 'none';
            }
        }

        function updateParticles(elapsedTime) {
            const positions = particles.geometry.attributes.position.array;
            const timeOffset = elapsedTime * params.timeScale;
            const turb = params.turbulence;
            const force = params.windForce;
            const globalSpeed = params.windSpeed;
            const baseX = params.baseX;
            const baseY = params.baseY;
            const basis = getLocalEnuBasis();
            const east = basis.east;
            const north = basis.north;
            const down = basis.down;

            for (let i = 0; i < params.count; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let px = positions[ix];
                let py = positions[iy];
                let pz = positions[iz];

                let noiseX = 0, noiseY = 0, noiseZ = 0;
                let amplitude = 1;
                let frequency = 1;
                
                for (let oct = 0; oct < params.noiseOctaves; oct++) {
                    noiseX += noise3D(px * turb * frequency, py * turb * frequency, timeOffset + oct * 100) * amplitude;
                    noiseY += noise3D(px * turb * frequency + 100, py * turb * frequency, timeOffset + oct * 100) * amplitude;
                    noiseZ += noise3D(px * turb * frequency + 200, py * turb * frequency, timeOffset + oct * 100) * amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }

                const eastSpeed = (baseX + noiseX * force) * globalSpeed;
                const northSpeed = (noiseZ * force) * globalSpeed;
                const downSpeed = Math.max(0.05, -(baseY + noiseY * force * 0.5)) * globalSpeed;

                const vx = east.x * eastSpeed + north.x * northSpeed + down.x * downSpeed;
                const vy = east.y * eastSpeed + north.y * northSpeed + down.y * downSpeed;
                const vz = east.z * eastSpeed + north.z * northSpeed + down.z * downSpeed;

                positions[ix] += vx;
                positions[iy] += vy;
                positions[iz] += vz;

                const boundary = areaSize / 2;
                
                if (positions[iy] < -boundary) {
                    positions[iy] = boundary;
                    positions[ix] = (Math.random() - 0.5) * areaSize;
                    positions[iz] = (Math.random() - 0.5) * areaSize;
                }
                if (positions[ix] > boundary) positions[ix] = -boundary;
                if (positions[ix] < -boundary) positions[ix] = boundary;
                if (positions[iz] > boundary) positions[iz] = -boundary;
                if (positions[iz] < -boundary) positions[iz] = boundary;
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }

        // ÂÖ≥ÈîÆ‰øÆÂ§ç:Ê≠£Á°ÆÁöÑÁõ∏Êú∫ÂêåÊ≠•ÊñπÊ≥ï
        function syncCesiumToThreeCamera() {
            const cesiumCamera = viewer.camera;
            
            // Ëé∑Âèñ Cesium Áõ∏Êú∫ÁöÑÂü∫ÂêëÈáè
            const cesiumRight = cesiumCamera.right;
            const cesiumUp = cesiumCamera.up;
            const cesiumDirection = cesiumCamera.direction;

            // ËΩ¨Êç¢Âà∞ Three.js ÂùêÊ†áÁ≥ª
            const right = cesiumToThreeVector(cesiumRight).normalize();
            const up = cesiumToThreeVector(cesiumUp).normalize();
            const forward = cesiumToThreeVector(cesiumDirection).normalize();

            // È™åËØÅÂêëÈáèÊúâÊïàÊÄß
            if (!isValidVector3(right) || !isValidVector3(up) || !isValidVector3(forward)) {
                return;
            }

            // ÊûÑÂª∫ÊóãËΩ¨Áü©Èòµ
            // Three.js Áõ∏Êú∫ÈªòËÆ§ÊúùÂêë -Z ËΩ¥
            const rotMatrix = new THREE.Matrix4();
            rotMatrix.makeBasis(right, up, forward.multiplyScalar(-1));
            
            // Â∫îÁî®ÊóãËΩ¨
            threeCamera.setRotationFromMatrix(rotMatrix);
            
            // Three.js Áõ∏Êú∫Âõ∫ÂÆöÂú®ÂéüÁÇπÔºàÁ≤íÂ≠êÁ≥ªÁªüÁõ∏ÂØπ‰∫éÁõ∏Êú∫Ôºâ
            threeCamera.position.set(0, 0, 0);
            
            // ÂêåÊ≠• FOVÔºà‰ªÖÂú®ÂêØÁî®Êó∂Ôºâ
            if (params.syncFov) {
                const cesiumFov = Cesium.Math.toDegrees(cesiumCamera.frustum.fov);
                if (Math.abs(threeCamera.fov - cesiumFov) > 0.1) {
                    threeCamera.fov = cesiumFov;
                    params.fov = cesiumFov;
                    if (guiState.controllers.fov) {
                        guiState.controllers.fov.setValue(cesiumFov);
                    }
                    threeCamera.updateProjectionMatrix();
                }
            }
        }

        function updateDebugInfo() {
            const info = document.getElementById('info');
            info.style.display = 'block';
            
            const cesiumCam = viewer.camera;
            const h = Cesium.Math.toDegrees(cesiumCam.heading).toFixed(1);
            const p = Cesium.Math.toDegrees(cesiumCam.pitch).toFixed(1);
            const r = Cesium.Math.toDegrees(cesiumCam.roll).toFixed(1);
            
            const cesiumFov = Cesium.Math.toDegrees(cesiumCam.frustum.fov).toFixed(1);
            const threeFov = threeCamera.fov.toFixed(1);
            const fovSync = params.syncFov ? '‚úì' : '‚úó';
            
            const basis = getLocalEnuBasis();
            
            info.innerHTML = `
                <strong>Cesium Camera HPR:</strong><br>
                H: ${h}¬∞ | P: ${p}¬∞ | R: ${r}¬∞<br>
                <br>
                <strong>FOV ÂêåÊ≠•Áä∂ÊÄÅ:</strong><br>
                Cesium FOV: ${cesiumFov}¬∞<br>
                Three.js FOV: ${threeFov}¬∞<br>
                Ëá™Âä®ÂêåÊ≠•: ${fovSync}<br>
                <br>
                <strong>Three.js Camera:</strong><br>
                Rotation: (${threeCamera.rotation.x.toFixed(2)}, ${threeCamera.rotation.y.toFixed(2)}, ${threeCamera.rotation.z.toFixed(2)})<br>
                <br>
                <strong>ENU Basis (Three.js coords):</strong><br>
                East: (${basis.east.x.toFixed(2)}, ${basis.east.y.toFixed(2)}, ${basis.east.z.toFixed(2)})<br>
                North: (${basis.north.x.toFixed(2)}, ${basis.north.y.toFixed(2)}, ${basis.north.z.toFixed(2)})<br>
                Up: (${basis.up.x.toFixed(2)}, ${basis.up.y.toFixed(2)}, ${basis.up.z.toFixed(2)})
            `;
        }
    </script>
</body>
</html>